package instrumentor;

import afl.Kelinci;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * @author Derrick Lockwood
 * @created 6/25/18.
 */
public class InstrumentLoader {

    private static final Logger LOGGER = Logger.getLogger(InstrumentLoader.class.getName());

    static {
        LOGGER.setParent(Logger.getLogger(Kelinci.class.getName()));
    }

    private InstrumentLoader() {}

    private static void clearFolder(File folder) {
        File[] files = folder.listFiles();
        if (files != null) { //some JVMs return null for empty dirs
            for (File f : files) {
                if (f.isDirectory()) {
                    clearFolder(f);
                    if (!f.delete()) {
                        LOGGER.log(Level.WARNING, "Can't delete folder " + folder.getPath());
                    }
                } else {
                    if (!f.delete()) {
                        LOGGER.log(Level.WARNING, "Can't delete file " + f.getPath());
                    }

                }
            }
        }
    }

    //TODO: Fix for Java 1.9
    public static void addToClassPath(File file) throws
            NoSuchMethodException,
            MalformedURLException,
            InvocationTargetException,
            IllegalAccessException {
        if (!file.exists()) {
            LOGGER.log(Level.SEVERE, "File " + file + " Doesn't exist");
            return;
        }
        addToClassPath(file.toURI().toURL());
    }

    public static void addToClassPath(URL url) throws
            NoSuchMethodException,
            InvocationTargetException,
            IllegalAccessException {
        addToClassPath(url, ClassLoader.getSystemClassLoader());
    }

    public static void addToClassPath(URL url, ClassLoader classLoader) throws
            NoSuchMethodException,
            InvocationTargetException,
            IllegalAccessException {

        Method method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
        method.setAccessible(true);
        method.invoke(classLoader, url);
    }

    private static boolean instrumentClass(String cls, InputStream classInputStream,
            OutputStream classOutputStream, URL... classPaths) {
        LoaderClassWriter cw = new LoaderClassWriter(ClassWriter.COMPUTE_FRAMES);
        cw.addClassPath(classPaths);
        ClassTransformer ct = new ClassTransformer(cw);
        ClassReader cr;
        try {
            cr = new ClassReader(classInputStream);
        } catch (IOException | NullPointerException e) {
            LOGGER.log(Level.SEVERE, "Error loading class " + cls, e);
            return false;
        }

        try {
            cr.accept(ct, 0);
            byte[] bytes = cw.toByteArray();
            classOutputStream.write(bytes);
        } catch (RuntimeException rte) {
            if (rte.getMessage().contains("JSR/RET")) {
					/*
					  This is an exception related to a particular construct in the bytecode that
					  is not supported by ASM. It is deprecated and should not be present in bytecode
					  generated by a recent compiler. However, the JDK contains it and it may occur elsewhere.
					  This catch simply skips the class and warns the user.
					 */
                LOGGER.log(Level.WARNING, "RuntimeException thrown during instrumentation: " + rte.getMessage());
                LOGGER.log(Level.WARNING, "Skipping instrumentation of class " + cls + "\n");
                // include original, uninstrumented class in output
                return writeClass(cls, classInputStream, classOutputStream);
            } else {
                LOGGER.log(Level.SEVERE, "Can't instrument class " + cls, rte);
                return false;
            }
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Can't write instrumented class " + cls, e);
            return false;
        }
        return true;
    }

    private static boolean instrumentClass(String cls, InputStream classInputStream,
            Path instrumentedDir, URL... classPaths) {
        LOGGER.log(Level.INFO, "Found class: " + cls);
        String instrumentedPath = instrumentedDir.resolve(cls).toString();
        File instrumentedClazz = new File(instrumentedPath);
        LOGGER.log(Level.INFO, "Instrumenting into " + instrumentedClazz.getPath());
        try {
            Files.createDirectories(instrumentedClazz.getParentFile().toPath());
            if (!instrumentedClazz.createNewFile()) {
                LOGGER.log(Level.SEVERE, "Can't create instrumented file " + instrumentedClazz.getAbsolutePath());
                return false;
            }
            OutputStream classOutputStream = new FileOutputStream(instrumentedClazz);
            if (!instrumentClass(cls, classInputStream, classOutputStream, classPaths)) {
                return false;
            }
        } catch (FileNotFoundException e) {
            LOGGER.log(Level.SEVERE, "Can't find file ", e);
            return false;
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Can't create instrumented class directories " + instrumentedClazz.getPath(), e);
            return false;
        }
        return true;
    }

    private static boolean instrumentClass(File clazz, URL libsClassPath, Path instrumentedDir) {
        URL classPath = getClassClassPath(clazz);
        if (classPath == null) {
            return false;
        }
        return instrumentClass(clazz, instrumentedDir, classPath, libsClassPath);
    }

    private static boolean instrumentClass(File clazz, Path instrumentedDir, URL... classPaths) {
        LOGGER.log(Level.INFO, "Found class: " + clazz.getPath());
        String instrumentedPath = instrumentedDir.resolve(clazz.toPath()).toString();
        File instrumentedClazz = new File(instrumentedPath);
        LOGGER.log(Level.INFO, "Instrumenting into " + instrumentedClazz.getPath());
        try {
            Files.createDirectories(instrumentedClazz.getParentFile().toPath());
            if (!instrumentedClazz.createNewFile()) {
                LOGGER.log(Level.SEVERE, "Can't create instrumented file " + instrumentedClazz.getAbsolutePath());
                return false;
            }
            InputStream classInputStream = new FileInputStream(clazz);
            OutputStream classOutputStream = new FileOutputStream(instrumentedClazz);
            if (!instrumentClass(clazz.getName(), classInputStream, classOutputStream, classPaths)) {
                return false;
            }
        } catch (FileNotFoundException e) {
            LOGGER.log(Level.SEVERE, "Can't find file ", e);
            return false;
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Can't create instrumented class directories " + instrumentedClazz.getPath(), e);
            return false;
        }
        return true;
    }

    private static boolean writeClass(String cls, InputStream inputStream, OutputStream outputStream) {
        byte[] buffer = new byte[1024];
        try {
            while (inputStream.read(buffer, 0, buffer.length) != -1) {
                outputStream.write(buffer);
            }
            outputStream.flush();
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Can't write class " + cls, e);
            return false;
        }
        return true;
    }

    private static URL getClassClassPath(File file) {
        URL classPath = null;
        try {
            classPath = new URL("file:" + file.getName());
        } catch (MalformedURLException e) {
            LOGGER.log(Level.SEVERE, "Error with classpath ", e);
        }
        return classPath;
    }

    private static URL getJarClassPath(File file) {
        URL classPath = null;
        try {
            classPath = new URL("jar:file:" + file.getName() + "!/");
        } catch (MalformedURLException e) {
            LOGGER.log(Level.SEVERE, "Error with jar classpath ", e);
        }
        return classPath;
    }

    private static URL getDirClassPath(File directory) {
        if (directory == null || !directory.exists() || !directory.isDirectory()) {
            return null;
        }
        URL classPath = null;
        String name = directory.getAbsolutePath();
        try {
            classPath = new URL("file:" + (name.endsWith("/") ? name : name + "/"));
        } catch (MalformedURLException e) {
            LOGGER.log(Level.SEVERE, "Error with directory classpath ", e);
        }
        return classPath;
    }

    private static boolean instrumentJar(File file, URL[] libsClassPaths, Path instrumentedDir) {
        URL classPath = getJarClassPath(file);
        if (classPath == null) {
            return false;
        }
        URL[] classPaths = new URL[libsClassPaths.length + 1];
        classPaths[0] = classPath;
        System.arraycopy(libsClassPaths, 0, classPaths, 1, libsClassPaths.length);
        try {
            // open JAR file
            JarFile jarFile = new JarFile(file);
            Enumeration<JarEntry> entries = jarFile.entries();

            // iterate JAR entries
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();
                File entryFile = new File(entryName);

                if (entryName.endsWith(".class")) {
                    if (!instrumentClass(entryName, jarFile.getInputStream(entry), instrumentedDir, classPaths)) {
                        return false;
                    }
                } else if (entryName.endsWith(".jar")) {
                    // load nested JAR
                    LOGGER.log(Level.INFO, "Found jar: " + entryName);
                    if (!instrumentJar(entryFile, libsClassPaths, instrumentedDir)) {
                        return false;
                    }
                }
            }

            // close JAR file
            jarFile.close();

        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Error reading from JAR file: " + file, e);
            return false;
        }
        return true;
    }

    private static File[] getAllClasses(File directory) {
        try {
            return Files.walk(directory.toPath())
                    .filter(path -> path.toString().contains(".class"))
                    .map(path -> new File(path.toString()))
                    .toArray(File[]::new);
        } catch (IOException e) {
            return null;
        }
    }

    private static boolean instrumentDir(File directory, URL libsClasspath, Path instrumentedDir) {
        URL classPath = getDirClassPath(directory);
        if (classPath == null) {
            return false;
        }

        File[] classes = getAllClasses(directory);
        if (classes == null || classes.length == 0) {
            LOGGER.log(Level.SEVERE, "No files found in " + directory.getPath());
            return false;
        }
        for (File clazz : classes) {
            if (!instrumentClass(clazz, instrumentedDir, classPath, libsClasspath)) {
                return false;
            }
        }
        return true;
    }

    private static boolean copyLibs(File src, File dest, File exceptApp, List<URL> libUrlList) {
        if (src == null || !src.exists()) {
            LOGGER.log(Level.SEVERE, "Can't copy from source directory " + src);
            return false;
        }
        if (src.isDirectory()) {
            if (!dest.exists()) {
                LOGGER.log(Level.INFO, "Making directory " + dest);
                if (!dest.mkdir()) {
                    LOGGER.log(Level.SEVERE, "Can't create destination directory " + dest);
                    return false;
                }
            }
            String[] files = src.list();
            if (files == null) {
                return true;
            }
            for (String file : files) {
                File srcFile = new File(src, file);
                File destFile = new File(dest, file);
                if (srcFile.equals(exceptApp)) {
                    continue;
                }
                if (!copyLibs(srcFile, destFile, exceptApp, libUrlList)) {
                    return false;
                }
            }
        } else {
            if (src.getName().endsWith(".jar")) {
                libUrlList.add(getJarClassPath(src));
            }
            try {
                InputStream inputStream = new FileInputStream(src);
                OutputStream outputStream = new FileOutputStream(dest);
                byte[] buffer = new byte[1024];
                int length;
                while ((length = inputStream.read(buffer)) > 0) {
                    outputStream.write(buffer, 0, length);
                }
                LOGGER.log(Level.FINE, "Copied " + src + " to " + dest);
            } catch (IOException e) {
                LOGGER.log(Level.SEVERE, "Can't copy " + src + " to " + dest, e);
                return false;
            }
        }
        return true;
    }

    private static boolean instrument(File inputSource, File libs, Path instrumentedDir) {
        LOGGER.log(Level.INFO, "Started adding libs to instrumented directory and to classpath");
        List<URL> urls = new ArrayList<>();
        if (!copyLibs(libs, instrumentedDir.toFile(), inputSource, urls)) {
            LOGGER.log(Level.WARNING, "Couldn't add libs to instrumented directory and classpath");
        }
        URL[] libUrls = urls.toArray(new URL[0]);
        if (inputSource.isFile()) {
            String name = inputSource.getName();
            if (name.endsWith(".jar")) {
                LOGGER.log(Level.INFO, "Started instrumenting jar " + inputSource.getPath());
                if (instrumentJar(inputSource, libUrls, instrumentedDir)) {
                    LOGGER.log(Level.INFO, "Finished instrumenting jar " + inputSource.getPath());
                } else {
                    return false;
                }
            } else if (name.endsWith(".class")) {
                LOGGER.log(Level.INFO, "Started instrumenting class " + inputSource.getPath());
                if (instrumentClass(inputSource, getDirClassPath(libs), instrumentedDir)) {
                    LOGGER.log(Level.INFO, "Finished instrumenting jar " + inputSource.getPath());
                } else {
                    return false;
                }
            } else {
                LOGGER.log(Level.SEVERE, "Can't read file as source " + inputSource.getPath());
                return false;
            }
        } else {
            LOGGER.log(Level.INFO, "Started instrumenting directory " + inputSource.getPath());
            if (instrumentDir(inputSource, getDirClassPath(libs), instrumentedDir)) {
                LOGGER.log(Level.INFO, "Finished instrumenting directory " + inputSource.getPath());
            } else {
                return false;
            }
        }
        return true;
    }

    public static boolean loadInstrumentedClasses(File inputSource, File libs, File instrumentedDir) {
        if (inputSource != null) {
            //Instrument and place in instrumented dir
            if (inputSource.exists()) {
                if (!instrumentedDir.exists()) {
                    LOGGER.log(Level.INFO, "Instrumented directory not there creating " + instrumentedDir.getName());
                    if (!instrumentedDir.mkdir()) {
                        LOGGER.log(Level.SEVERE, "Can't create instrumented directory " + instrumentedDir.getName());
                        return false;
                    }
                } else if (instrumentedDir.isFile()) {
                    LOGGER.log(Level.SEVERE, "Instrumented directory isn't a directory " + instrumentedDir.getName());
                    return false;
                } else {
                    LOGGER.log(Level.INFO, "Clearing directory " + instrumentedDir.getPath());
                    clearFolder(instrumentedDir);
                }
                LOGGER.log(Level.INFO, "Instrumenting " + inputSource.getName() + " to " + instrumentedDir.getPath());
                if (!instrument(inputSource, libs, instrumentedDir.toPath())) {
                    return false;
                }
            } else {
                LOGGER.log(Level.WARNING,
                        "Input Source " + inputSource.getName() + " doesn't exist. Continuing without instrumenting");
                if (!instrumentedDir.exists()) {
                    LOGGER.log(Level.SEVERE, "Instrumented directory doesn't exist " + instrumentedDir.getName());
                    return false;
                } else if (instrumentedDir.isFile()) {
                    LOGGER.log(Level.SEVERE, "Instrumented directory isn't a directory " + instrumentedDir.getName());
                    return false;
                }
            }
        } else {
            if (!instrumentedDir.exists()) {
                LOGGER.log(Level.SEVERE, "Instrumented directory doesn't exist " + instrumentedDir.getName());
                return false;
            } else if (instrumentedDir.isFile()) {
                LOGGER.log(Level.SEVERE, "Instrumented directory isn't a directory " + instrumentedDir.getName());
                return false;
            }
        }
        try {
            LOGGER.log(Level.INFO, "Adding to classpath " + instrumentedDir.getPath());
            addToClassPath(instrumentedDir);
        } catch (NoSuchMethodException | MalformedURLException | InvocationTargetException | IllegalAccessException e) {
            LOGGER.log(Level.SEVERE, "Error with adding instrumented directory to class path", e);
            return false;
        }
        return true;
    }
}
